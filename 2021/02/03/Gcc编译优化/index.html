<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Gcc编译优化 | echo</title><meta name="keywords" content="linux"><meta name="author" content="echo"><meta name="copyright" content="echo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="GCC编译优化选项O0优化：不做任何优化，这是默认的编译选项。O和O1：对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。打开的优化选项：  l -fdefer-pop：延迟栈的弹出时间。当完成一个函数调用，参数并不马上从栈中弹出，而是在多个函数被调用后，一次性弹出。  l">
<meta property="og:type" content="article">
<meta property="og:title" content="Gcc编译优化">
<meta property="og:url" content="http://example.com/2021/02/03/Gcc%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="echo">
<meta property="og:description" content="GCC编译优化选项O0优化：不做任何优化，这是默认的编译选项。O和O1：对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。打开的优化选项：  l -fdefer-pop：延迟栈的弹出时间。当完成一个函数调用，参数并不马上从栈中弹出，而是在多个函数被调用后，一次性弹出。  l">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://p9.qhimg.com/bdr/__85/t01269a467cd28225d2.jpg">
<meta property="article:published_time" content="2021-02-03T10:28:01.000Z">
<meta property="article:modified_time" content="2021-02-03T10:29:03.000Z">
<meta property="article:author" content="echo">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://p9.qhimg.com/bdr/__85/t01269a467cd28225d2.jpg"><link rel="shortcut icon" href="http://p8.qhimg.com/bdm/800_600_100/t012b0a4dba0add8b86.jpg"><link rel="canonical" href="http://example.com/2021/02/03/Gcc%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-02-03 18:29:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'true'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1602674028&amp;di=d172ead1852b69507d79279bf80efc54&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202009%2F15%2F20200915202836_6632b.thumb.1000_0.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">54</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GCC%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9"><span class="toc-number">1.</span> <span class="toc-text">GCC编译优化选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#O0%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">O0优化：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%8C%E8%BF%99%E6%98%AF%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E3%80%82"><span class="toc-number">2.1.</span> <span class="toc-text">不做任何优化，这是默认的编译选项。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#O%E5%92%8CO1%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">O和O1：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%81%9A%E9%83%A8%E5%88%86%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%87%BD%E6%95%B0-%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%8D%A0%E7%94%A8%E7%A8%8D%E5%BE%AE%E5%A4%9A%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E7%9B%B8%E5%BD%93%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E3%80%82%E4%BD%BF%E7%94%A8%E6%9C%AC%E9%A1%B9%E4%BC%98%E5%8C%96%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E5%B0%9D%E8%AF%95%E5%87%8F%E5%B0%8F%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%BA%E5%AF%B8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%BC%A9%E7%9F%AD%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%89%A7%E8%A1%8C%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E5%A4%A7%E9%87%8F%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%98%E5%8C%96%E3%80%82"><span class="toc-number">3.1.</span> <span class="toc-text">对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fdefer-pop%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">l -fdefer-pop：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fmerge-constants%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">l -fmerge-constants：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fthread-jumps%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">l -fthread-jumps：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-floop-optimize%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">l -floop-optimize：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fif-conversion%EF%BC%9A"><span class="toc-number">3.1.5.</span> <span class="toc-text">l -fif-conversion：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fdelayed-branch%EF%BC%9A"><span class="toc-number">3.1.6.</span> <span class="toc-text">l -fdelayed-branch：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fguess-branch-probability%EF%BC%9A"><span class="toc-number">3.1.7.</span> <span class="toc-text">l -fguess-branch-probability：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fcprop-registers%EF%BC%9A"><span class="toc-number">3.1.8.</span> <span class="toc-text">l -fcprop-registers：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#O2%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">-O2：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E6%AF%94O1%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E9%80%89%E9%A1%B9%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BC%98%E5%8C%96%E3%80%82Gcc%E5%B0%86%E6%89%A7%E8%A1%8C%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8C%85%E5%90%AB%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%8A%98%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E3%80%82%E5%BD%93%E8%AE%BE%E7%BD%AEO2%E9%80%89%E9%A1%B9%E6%97%B6%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%B9%B6%E4%B8%8D%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%89%93%E5%BC%80%EF%BC%88%EF%BC%89loop-unrolling%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E3%80%82%E4%B8%8EO1%E6%AF%94%E8%BE%83%E8%80%8C%E8%A8%80%EF%BC%8CO2%E4%BC%98%E5%8C%96%E5%A2%9E%E5%8A%A0%E4%BA%86%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E6%8F%90%E9%AB%98%E4%BA%86%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E3%80%82"><span class="toc-number">4.1.</span> <span class="toc-text">是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fforce-mem%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">l -fforce-mem：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-foptimize-sibling-calls%EF%BC%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">l -foptimize-sibling-calls：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fstrength-reduce%EF%BC%9A"><span class="toc-number">4.1.3.</span> <span class="toc-text">l -fstrength-reduce：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fcse-follow-jumps%EF%BC%9A"><span class="toc-number">4.1.4.</span> <span class="toc-text">l -fcse-follow-jumps：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fcse-skip-blocks%EF%BC%9A"><span class="toc-number">4.1.5.</span> <span class="toc-text">l -fcse-skip-blocks：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-frerun-cse-after-loop%EF%BC%9A"><span class="toc-number">4.1.6.</span> <span class="toc-text">l -frerun-cse-after-loop：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-frerun-loop-opt%EF%BC%9A"><span class="toc-number">4.1.7.</span> <span class="toc-text">l -frerun-loop-opt：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fgcse-lm%EF%BC%9A%E5%85%A8%E5%B1%80%E5%85%AC%E7%94%A8%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4%E5%B0%86%E8%AF%95%E5%9B%BE%E7%A7%BB%E5%8A%A8%E9%82%A3%E4%BA%9B%E4%BB%85%E4%BB%85%E8%A2%AB%E8%87%AA%E8%BA%AB%E5%AD%98%E5%82%A8kill%E7%9A%84%E8%A3%85%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%82%E8%BF%99%E5%B0%86%E5%85%81%E8%AE%B8%E5%B0%86%E5%BE%AA%E7%8E%AF%E5%86%85%E7%9A%84load-store%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84load%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%A4%96%E9%9D%A2%EF%BC%88%E5%8F%AA%E9%9C%80%E8%A6%81%E8%A3%85%E8%BD%BD%E4%B8%80%E6%AC%A1%EF%BC%89%EF%BC%8C%E8%80%8C%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%86%85%E6%94%B9%E5%8F%98%E6%88%90copy-store%E5%BA%8F%E5%88%97%E3%80%82%E5%9C%A8%E9%80%89%E4%B8%AD-fgcse%E5%90%8E%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E3%80%82"><span class="toc-number">4.1.8.</span> <span class="toc-text">l-fgcse-lm：全局公用子表达式消除将试图移动那些仅仅被自身存储kill的装载操作的位置。这将允许将循环内的load&#x2F;store操作序列中的load转移到循环的外面（只需要装载一次），而在循环内改变成copy&#x2F;store序列。在选中-fgcse后，默认打开。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fgcse-sm%EF%BC%9A"><span class="toc-number">4.1.9.</span> <span class="toc-text">l -fgcse-sm：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fgcse-las%EF%BC%9A"><span class="toc-number">4.1.10.</span> <span class="toc-text">l -fgcse-las：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fdelete-null-pointer-checks%EF%BC%9A"><span class="toc-number">4.1.11.</span> <span class="toc-text">l-fdelete-null-pointer-checks：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fexpensive-optimizations%EF%BC%9A"><span class="toc-number">4.1.12.</span> <span class="toc-text">l -fexpensive-optimizations：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fregmove%EF%BC%9A"><span class="toc-number">4.1.13.</span> <span class="toc-text">l -fregmove：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fschedule-insns%EF%BC%9A"><span class="toc-number">4.1.14.</span> <span class="toc-text">l -fschedule-insns：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fschedule-insns2%EF%BC%9A"><span class="toc-number">4.1.15.</span> <span class="toc-text">-fschedule-insns2：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fsched-interblock%EF%BC%9A"><span class="toc-number">4.1.16.</span> <span class="toc-text">l -fsched-interblock：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fsched-spec-load%EF%BC%9A"><span class="toc-number">4.1.17.</span> <span class="toc-text">l -fsched-spec-load：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fcaller-saves%EF%BC%9A"><span class="toc-number">4.1.18.</span> <span class="toc-text">l -fcaller-saves：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fpeephole2%EF%BC%9A"><span class="toc-number">4.1.19.</span> <span class="toc-text">l -fpeephole2：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-freorder-blocks%EF%BC%9A"><span class="toc-number">4.1.20.</span> <span class="toc-text">l -freorder-blocks：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-freorder-functions%EF%BC%9A"><span class="toc-number">4.1.21.</span> <span class="toc-text">l -freorder-functions：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fstrict-aliasing%EF%BC%9A"><span class="toc-number">4.1.22.</span> <span class="toc-text">l -fstrict-aliasing：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-funit-at-a-time%EF%BC%9A"><span class="toc-number">4.1.23.</span> <span class="toc-text">l -funit-at-a-time：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-falign-functions%EF%BC%9A"><span class="toc-number">4.1.24.</span> <span class="toc-text">l -falign-functions：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-falign-jumps%EF%BC%9A"><span class="toc-number">4.1.25.</span> <span class="toc-text">l -falign-jumps：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-falign-loops%EF%BC%9A"><span class="toc-number">4.1.26.</span> <span class="toc-text">l -falign-loops：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-falign-labels%EF%BC%9A"><span class="toc-number">4.1.27.</span> <span class="toc-text">l -falign-labels：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fcrossjumping%EF%BC%9A"><span class="toc-number">4.1.28.</span> <span class="toc-text">l -fcrossjumping：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#O3%EF%BC%9A-%E6%AF%94O2%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">-O3： 比O2更进一步的进行优化。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%8C%85%E5%90%AB%E4%BA%86O2%E6%89%80%E6%9C%89%E7%9A%84%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E5%8F%88%E6%89%93%E5%BC%80%E4%BA%86%E4%BB%A5%E4%B8%8B%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">在包含了O2所有的优化的基础上，又打开了以下优化选项：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#l-finline-functions%EF%BC%9A"><span class="toc-number">5.1.1.</span> <span class="toc-text">l -finline-functions：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-fweb%EF%BC%9A"><span class="toc-number">5.1.2.</span> <span class="toc-text">l -fweb：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-frename-registers%EF%BC%9A"><span class="toc-number">5.1.3.</span> <span class="toc-text">l -frename-registers：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l-funswitch-loops%EF%BC%9A"><span class="toc-number">5.1.4.</span> <span class="toc-text">l -funswitch-loops：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Os%EF%BC%9A-%E4%B8%BB%E8%A6%81%E6%98%AF%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B0%BA%E5%AF%B8%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">-Os： 主要是对程序的尺寸进行优化。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#O1%E4%BC%98%E5%8C%96%E4%BC%9A%E6%B6%88%E8%80%97%E5%B0%91%E5%A4%9A%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%EF%BC%8C%E5%AE%83%E4%B8%BB%E8%A6%81%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E5%88%86%E6%94%AF%EF%BC%8C%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AD%89%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E3%80%82"><span class="toc-number">7.1.</span> <span class="toc-text">O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O2%E4%BC%9A%E5%B0%9D%E8%AF%95%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BA%A7%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E6%8C%87%E4%BB%A4%E7%BA%A7%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E5%AE%83%E4%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E5%8D%A0%E7%94%A8%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%86%85%E5%AD%98%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E3%80%82"><span class="toc-number">7.2.</span> <span class="toc-text">O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O3%E5%9C%A8O2%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%BF%9B%E8%A1%8C%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BE%8B%E5%A6%82%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%AF%84%E5%AD%98%E5%99%A8%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E8%81%94%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%92%88%E5%AF%B9%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BC%98%E5%8C%96%E3%80%82"><span class="toc-number">7.3.</span> <span class="toc-text">O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Os%E4%B8%BB%E8%A6%81%E6%98%AF%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9F%BA%E6%9C%AC%E4%B8%8D%E7%94%A8%E5%81%9A%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E5%BF%83%E3%80%82-%E9%80%9A%E5%B8%B8%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E9%83%BD%E4%BC%9A%E6%89%93%E4%B9%B1%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E8%AE%A9%E8%B0%83%E8%AF%95%E5%B7%A5%E4%BD%9C%E5%8F%98%E5%BE%97%E6%97%A0%E4%BB%8E%E7%9D%80%E6%89%8B%E3%80%82%E5%B9%B6%E4%B8%94%E4%BC%9A%E6%89%93%E4%B9%B1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%8C%E4%BE%9D%E8%B5%96%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E5%81%9A%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%E6%89%8D%E8%83%BD%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E3%80%82"><span class="toc-number">7.4.</span> <span class="toc-text">Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E6%9C%89%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">优化代码有可能带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8E%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">1．调试问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8E%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F%E6%94%B9%E5%8F%98%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">2．内存操作顺序改变所带来的问题：</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(http://p9.qhimg.com/bdr/__85/t01269a467cd28225d2.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">echo</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Gcc编译优化</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-03T10:28:01.000Z" title="发表于 2021-02-03 18:28:01">2021-02-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-03T10:29:03.000Z" title="更新于 2021-02-03 18:29:03">2021-02-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="GCC编译优化选项"><a href="#GCC编译优化选项" class="headerlink" title="GCC编译优化选项"></a>GCC编译优化选项</h1><h1 id="O0优化："><a href="#O0优化：" class="headerlink" title="O0优化："></a>O0优化：</h1><h2 id="不做任何优化，这是默认的编译选项。"><a href="#不做任何优化，这是默认的编译选项。" class="headerlink" title="不做任何优化，这是默认的编译选项。"></a>不做任何优化，这是默认的编译选项。</h2><h1 id="O和O1："><a href="#O和O1：" class="headerlink" title="O和O1："></a>O和O1：</h1><h2 id="对程序做部分编译优化，对于大函数-优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。"><a href="#对程序做部分编译优化，对于大函数-优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。" class="headerlink" title="对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。"></a>对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。</h2><p>打开的优化选项： </p>
<h3 id="l-fdefer-pop："><a href="#l-fdefer-pop：" class="headerlink" title="l -fdefer-pop："></a>l -fdefer-pop：</h3><p>延迟栈的弹出时间。当完成一个函数调用，参数并不马上从栈中弹出，而是在多个函数被调用后，一次性弹出。 </p>
<h3 id="l-fmerge-constants："><a href="#l-fmerge-constants：" class="headerlink" title="l -fmerge-constants："></a>l -fmerge-constants：</h3><p>尝试横跨编译单元合并同样的常量(string constants and floating point constants) </p>
<h3 id="l-fthread-jumps："><a href="#l-fthread-jumps：" class="headerlink" title="l -fthread-jumps："></a>l -fthread-jumps：</h3><p>如果某个跳转分支的目的地存在另一个条件比较,而且该条件比较包含在前一个比较语句之内,那么执行本项优化.根据条件是true或者false,前面那条分支重定向到第二条分支的目的地或者紧跟在第二条分支后面. </p>
<h3 id="l-floop-optimize："><a href="#l-floop-optimize：" class="headerlink" title="l -floop-optimize："></a>l -floop-optimize：</h3><p>执行循环优化,将常量表达式从循环中移除，简化判断循环的条件，并且optionally do strength-reduction，或者将循环打开等。在大型复杂的循环中，这种优化比较显著。 </p>
<h3 id="l-fif-conversion："><a href="#l-fif-conversion：" class="headerlink" title="l -fif-conversion："></a>l -fif-conversion：</h3><p>尝试将条件跳转转换为等价的无分支型式。优化实现方式包括条件移动，min，max，设置标志，以及abs指令，以及一些算术技巧等。 </p>
<p>l -fif-conversion2基本意义相同，没有找到更多的解释。 </p>
<h3 id="l-fdelayed-branch："><a href="#l-fdelayed-branch：" class="headerlink" title="l -fdelayed-branch："></a>l -fdelayed-branch：</h3><p>这种技术试图根据指令周期时间重新安排指令。 它还试图把尽可能多的指令移动到条件分支前, 以便最充分的利用处理器的治理缓存。 </p>
<h3 id="l-fguess-branch-probability："><a href="#l-fguess-branch-probability：" class="headerlink" title="l -fguess-branch-probability："></a>l -fguess-branch-probability：</h3><p>当没有可用的profiling feedback或__builtin_expect时，编译器采用随机模式猜测分支被执行的可能性，并移动对应汇编代码的位置，这有可能导致不同的编译器会编译出迥然不同的目标代码。 </p>
<h3 id="l-fcprop-registers："><a href="#l-fcprop-registers：" class="headerlink" title="l -fcprop-registers："></a>l -fcprop-registers：</h3><p>因为在函数中把寄存器分配给变量, 所以编译器执行第二次检查以便减少调度依赖性(两个段要求使用相同的寄存器)并且删除不必要的寄存器复制操作。 </p>
<h1 id="O2："><a href="#O2：" class="headerlink" title="-O2："></a>-O2：</h1><h2 id="是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop-unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。"><a href="#是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop-unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。" class="headerlink" title="是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。"></a>是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。</h2><p>O2打开所有的O1选项，并打开以下选项： </p>
<h3 id="l-fforce-mem："><a href="#l-fforce-mem：" class="headerlink" title="l -fforce-mem："></a>l -fforce-mem：</h3><p>在做算术操作前，强制将内存数据copy到寄存器中以后再执行。这会使所有的内存引用潜在的共同表达式，进而产出更高效的代码，当没有共同的子表达式时，指令合并将排出个别的寄存器载入。这种优化对于只涉及单一指令的变量, 这样也许不会有很大的优化效果. 但是对于再很多指令(必须数学操作)中都涉及到的变量来说, 这会时很显著的优化, 因为和访问内存中的值相比 ,处理器访问寄存器中的值要快的多。 </p>
<h3 id="l-foptimize-sibling-calls："><a href="#l-foptimize-sibling-calls：" class="headerlink" title="l -foptimize-sibling-calls："></a>l -foptimize-sibling-calls：</h3><p>优化相关的以及末尾递归的调用。通常, 递归的函数调用可以被展开为一系列一般的指令， 而不是使用分支。 这样处理器的指令缓存能够加载展开的指令并且处理他们, 和指令保持为需要分支操作的单独函数调用相比, 这样更快。 </p>
<h3 id="l-fstrength-reduce："><a href="#l-fstrength-reduce：" class="headerlink" title="l -fstrength-reduce："></a>l -fstrength-reduce：</h3><p>这种优化技术对循环执行优化并且删除迭代变量。 迭代变量是捆绑到循环计数器的变量, 比如使用变量, 然后使用循环计数器变量执行数学操作的for-next循环。 </p>
<h3 id="l-fcse-follow-jumps："><a href="#l-fcse-follow-jumps：" class="headerlink" title="l -fcse-follow-jumps："></a>l -fcse-follow-jumps：</h3><p>在公用子表达式消元时，当目标跳转不会被其他路径可达，则扫描整个的跳转表达式。例如，当公用子表达式消元时遇到if…else…语句时，当条为false时，那么公用子表达式消元会跟随着跳转。  </p>
<h3 id="l-fcse-skip-blocks："><a href="#l-fcse-skip-blocks：" class="headerlink" title="l -fcse-skip-blocks："></a>l -fcse-skip-blocks：</h3><p>与-fcse-follow-jumps类似，不同的是，根据特定条件，跟随着cse跳转的会是整个的blocks </p>
<h3 id="l-frerun-cse-after-loop："><a href="#l-frerun-cse-after-loop：" class="headerlink" title="l -frerun-cse-after-loop："></a>l -frerun-cse-after-loop：</h3><p>在循环优化完成后，重新进行公用子表达式消元操作。 </p>
<h3 id="l-frerun-loop-opt："><a href="#l-frerun-loop-opt：" class="headerlink" title="l -frerun-loop-opt："></a>l -frerun-loop-opt：</h3><p>两次运行循环优化 l -fgcse：执行全局公用子表达式消除pass。这个pass还执行全局常量和copy propagation。这些优化操作试图分析生成的汇编语言代码并且结合通用片段， 消除冗余的代码段。如果代码使用计算性的goto, gcc指令推荐使用-fno-gcse选项。 </p>
<h3 id="l-fgcse-lm：全局公用子表达式消除将试图移动那些仅仅被自身存储kill的装载操作的位置。这将允许将循环内的load-store操作序列中的load转移到循环的外面（只需要装载一次），而在循环内改变成copy-store序列。在选中-fgcse后，默认打开。"><a href="#l-fgcse-lm：全局公用子表达式消除将试图移动那些仅仅被自身存储kill的装载操作的位置。这将允许将循环内的load-store操作序列中的load转移到循环的外面（只需要装载一次），而在循环内改变成copy-store序列。在选中-fgcse后，默认打开。" class="headerlink" title="l-fgcse-lm：全局公用子表达式消除将试图移动那些仅仅被自身存储kill的装载操作的位置。这将允许将循环内的load/store操作序列中的load转移到循环的外面（只需要装载一次），而在循环内改变成copy/store序列。在选中-fgcse后，默认打开。"></a>l-fgcse-lm：全局公用子表达式消除将试图移动那些仅仅被自身存储kill的装载操作的位置。这将允许将循环内的load/store操作序列中的load转移到循环的外面（只需要装载一次），而在循环内改变成copy/store序列。在选中-fgcse后，默认打开。</h3><h3 id="l-fgcse-sm："><a href="#l-fgcse-sm：" class="headerlink" title="l -fgcse-sm："></a>l -fgcse-sm：</h3><p>当一个存储操作pass在一个全局公用子表达式消除的后面，这个pass将试图将store操作转移到循环外面去。如果与-fgcse-lm配合使用，那么load/store操作将会转变为在循环前load，在循环后store，从而提高运行效率，减少不必要的操作。 </p>
<h3 id="l-fgcse-las："><a href="#l-fgcse-las：" class="headerlink" title="l -fgcse-las："></a>l -fgcse-las：</h3><p>全局公用子表达式消除pass将消除在store后面的不必要的load操作，这些load与store通常是同一块存储单元（全部或局部） </p>
<h3 id="l-fdelete-null-pointer-checks："><a href="#l-fdelete-null-pointer-checks：" class="headerlink" title="l-fdelete-null-pointer-checks："></a>l-fdelete-null-pointer-checks：</h3><p>通过对全局数据流的分析，识别并排出无用的对空指针的检查。编译器假设间接引用空指针将停止程序。 如果在间接引用之后检查指针，它就不可能为空。 </p>
<h3 id="l-fexpensive-optimizations："><a href="#l-fexpensive-optimizations：" class="headerlink" title="l -fexpensive-optimizations："></a>l -fexpensive-optimizations：</h3><p>进行一些从编译的角度来说代价高昂的优化（这种优化据说对于程序执行未必有很大的好处，甚至有可能降低执行效率，具体不是很清楚） </p>
<h3 id="l-fregmove："><a href="#l-fregmove：" class="headerlink" title="l -fregmove："></a>l -fregmove：</h3><p>编译器试图重新分配move指令或者其他类似操作数等简单指令的寄存器数目，以便最大化的捆绑寄存器的数目。这种优化尤其对双操作数指令的机器帮助较大。 </p>
<h3 id="l-fschedule-insns："><a href="#l-fschedule-insns：" class="headerlink" title="l -fschedule-insns："></a>l -fschedule-insns：</h3><p>编译器尝试重新排列指令，用以消除由于等待未准备好的数据而产生的延迟。这种优化将对慢浮点运算的机器以及需要load memory的指令的执行有所帮助，因为此时允许其他指令执行，直到load memory的指令完成，或浮点运算的指令再次需要cpu。 l </p>
<h3 id="fschedule-insns2："><a href="#fschedule-insns2：" class="headerlink" title="-fschedule-insns2："></a>-fschedule-insns2：</h3><p>与-fschedule-insns相似。但是当寄存器分配完成后，会请求一个附加的指令计划pass。这种优化对寄存器较小，并且load memory操作时间大于一个时钟周期的机器有非常好的效果。 </p>
<h3 id="l-fsched-interblock："><a href="#l-fsched-interblock：" class="headerlink" title="l -fsched-interblock："></a>l -fsched-interblock：</h3><p>这种技术使编译器能够跨越指令块调度指令。 这可以非常灵活地移动指令以便等待期间完成的工作最大化。 </p>
<h3 id="l-fsched-spec-load："><a href="#l-fsched-spec-load：" class="headerlink" title="l -fsched-spec-load："></a>l -fsched-spec-load：</h3><p>允许一些load指令进行一些投机性的动作。（具体不详）相同功能的还有-fsched-spec-load-dangerous，允许更多的load指令进行投机性操作。这两个选项在选中-fschedule-insns时默认打开。 </p>
<h3 id="l-fcaller-saves："><a href="#l-fcaller-saves：" class="headerlink" title="l -fcaller-saves："></a>l -fcaller-saves：</h3><p>通过存储和恢复call调用周围寄存器的方式，使被call调用的value可以被分配给寄存器，这种只会在看上去能产生更好的代码的时候才被使用。（如果调用多个函数, 这样能够节省时间, 因为只进行一次寄存器的保存和恢复操作, 而不是在每个函数调用中都进行。） </p>
<h3 id="l-fpeephole2："><a href="#l-fpeephole2：" class="headerlink" title="l -fpeephole2："></a>l -fpeephole2：</h3><p>允许计算机进行特定的观察孔优化(这个不晓得是什么意思)，-fpeephole与-fpeephole2的差别在于不同的编译器采用不同的方式，由的采用-fpeephole，有的采用-fpeephole2，也有两种都采用的。 </p>
<h3 id="l-freorder-blocks："><a href="#l-freorder-blocks：" class="headerlink" title="l -freorder-blocks："></a>l -freorder-blocks：</h3><p>在编译函数的时候重新安排基本的块，目的在于减少分支的个数，提高代码的局部性。 </p>
<h3 id="l-freorder-functions："><a href="#l-freorder-functions：" class="headerlink" title="l -freorder-functions："></a>l -freorder-functions：</h3><p>在编译函数的时候重新安排基本的块，目的在于减少分支的个数，提高代码的局部性。这种优化的实施依赖特定的已存在的信息：.text.hot用于告知访问频率较高的函数，.text.unlikely用于告知基本不被执行的函数。 </p>
<h3 id="l-fstrict-aliasing："><a href="#l-fstrict-aliasing：" class="headerlink" title="l -fstrict-aliasing："></a>l -fstrict-aliasing：</h3><p>这种技术强制实行高级语言的严格变量规则。 对于c和c++程序来说, 它确保不在数据类型之间共享变量. 例如, 整数变量不和单精度浮点变量使用相同的内存位置。 </p>
<h3 id="l-funit-at-a-time："><a href="#l-funit-at-a-time：" class="headerlink" title="l -funit-at-a-time："></a>l -funit-at-a-time：</h3><p>在代码生成前，先分析整个的汇编语言代码。这将使一些额外的优化得以执行，但是在编译器间需要消耗大量的内存。（有资料介绍说：这使编译器可以重新安排不消耗大量时间的代码以便优化指令缓存。） </p>
<h3 id="l-falign-functions："><a href="#l-falign-functions：" class="headerlink" title="l -falign-functions："></a>l -falign-functions：</h3><p>这个选项用于使函数对准内存中特定边界的开始位置。 大多数处理器按照页面读取内存，并且确保全部函数代码位于单一内存页面内, 就不需要叫化代码所需的页面。 </p>
<h3 id="l-falign-jumps："><a href="#l-falign-jumps：" class="headerlink" title="l -falign-jumps："></a>l -falign-jumps：</h3><p>对齐分支代码到2的n次方边界。在这种情况下，无需执行傀儡指令（dummy operations） </p>
<h3 id="l-falign-loops："><a href="#l-falign-loops：" class="headerlink" title="l -falign-loops："></a>l -falign-loops：</h3><p>对齐循环到2的n次幂边界。期望可以对循环执行多次，用以补偿运行dummy operations所花费的时间。 </p>
<h3 id="l-falign-labels："><a href="#l-falign-labels：" class="headerlink" title="l -falign-labels："></a>l -falign-labels：</h3><p>对齐分支到2的n次幂边界。这种选项容易使代码速度变慢，原因是需要插入一些dummy operations当分支抵达usual flow of the code. </p>
<h3 id="l-fcrossjumping："><a href="#l-fcrossjumping：" class="headerlink" title="l -fcrossjumping："></a>l -fcrossjumping：</h3><p>这是对跨越跳转的转换代码处理， 以便组合分散在程序各处的相同代码。 这样可以减少代码的长度， 但是也许不会对程序性能有直接影响。</p>
<h1 id="O3：-比O2更进一步的进行优化。"><a href="#O3：-比O2更进一步的进行优化。" class="headerlink" title="-O3： 比O2更进一步的进行优化。"></a>-O3： 比O2更进一步的进行优化。</h1><h2 id="在包含了O2所有的优化的基础上，又打开了以下优化选项："><a href="#在包含了O2所有的优化的基础上，又打开了以下优化选项：" class="headerlink" title="在包含了O2所有的优化的基础上，又打开了以下优化选项："></a>在包含了O2所有的优化的基础上，又打开了以下优化选项：</h2><h3 id="l-finline-functions："><a href="#l-finline-functions：" class="headerlink" title="l -finline-functions："></a>l -finline-functions：</h3><p>内联简单的函数到被调用函数中。由编译器启发式的决定哪些函数足够简单可以做这种内联优化。默认情况下，编译器限制内联的尺寸，3.4.6中限制为600（具体含义不详，指令条数或代码size？）可以通过-finline-limit=n改变这个长度。这种优化技术不为函数创建单独的汇编语言代码， 而是把函数代码包含在调度程序的代码中。 对于多次被调用的函数来说, 为每次函数调用复制函数代码。 虽然这样对于减少代码长度不利, 但是通过最充分的利用指令缓存代码, 而不是在每次函数调用时进行分支操作, 可以提高性能。 </p>
<h3 id="l-fweb："><a href="#l-fweb：" class="headerlink" title="l -fweb："></a>l -fweb：</h3><p>构建用于保存变量的伪寄存器网络。 伪寄存器包含数据, 就像他们是寄存器一样, 但是可以使用各种其他优化技术进行优化, 比如cse和loop优化技术。这种优化会使得调试变得更加的不可能，因为变量不再存放于原本的寄存器中。 </p>
<h3 id="l-frename-registers："><a href="#l-frename-registers：" class="headerlink" title="l -frename-registers："></a>l -frename-registers：</h3><p>在寄存器分配后，通过使用registers left over来避免预定代码中的虚假依赖。这会使调试变得非常困难，因为变量不再存放于原本的寄存器中了。 </p>
<h3 id="l-funswitch-loops："><a href="#l-funswitch-loops：" class="headerlink" title="l -funswitch-loops："></a>l -funswitch-loops：</h3><p>将无变化的条件分支移出循环，取而代之的将结果副本放入循环中。 </p>
<h1 id="Os：-主要是对程序的尺寸进行优化。"><a href="#Os：-主要是对程序的尺寸进行优化。" class="headerlink" title="-Os： 主要是对程序的尺寸进行优化。"></a>-Os： 主要是对程序的尺寸进行优化。</h1><p>打开了大部分O2优化中不会增加程序大小的优化选项，并对程序代码的大小做更深层的优化。（通常我们不需要这种优化）Os会关闭如下选项： -falign-functions -falign-jumps -falign-loops -falign-labels  -freorder-blocks  -fprefetch-loop-arrays  </p>
<p>优化介绍小结 O0选项不进行任何优化，在这种情况下，编译器尽量的缩短编译消耗（时间，空间），此时，debug会产出和程序预期的结果。当程序运行被断点打断，此时程序内的各种声明是独立的，我们可以任意的给变量赋值，或者在函数体内把程序计数器指到其他语句,以及从源程序中 精确地获取你期待的结果. </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。"><a href="#O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。" class="headerlink" title="O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。"></a>O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。</h2><h2 id="O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。"><a href="#O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。" class="headerlink" title="O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。"></a>O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。</h2><h2 id="O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。"><a href="#O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。" class="headerlink" title="O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。"></a>O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。</h2><h2 id="Os主要是对代码大小的优化，我们基本不用做更多的关心。-通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。"><a href="#Os主要是对代码大小的优化，我们基本不用做更多的关心。-通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。" class="headerlink" title="Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。"></a>Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。</h2><h1 id="优化代码有可能带来的问题"><a href="#优化代码有可能带来的问题" class="headerlink" title="优化代码有可能带来的问题"></a>优化代码有可能带来的问题</h1><h2 id="1．调试问题："><a href="#1．调试问题：" class="headerlink" title="1．调试问题："></a>1．调试问题：</h2><p>正如上面所提到的，任何级别的优化都将带来代码结构的改变。例如：对分支的合并和消除，对公用子表达式的消除，对循环内load/store操作的替换和更改等，都将会使目标代码的执行顺序变得面目全非，导致调试信息严重不足。 </p>
<h2 id="2．内存操作顺序改变所带来的问题："><a href="#2．内存操作顺序改变所带来的问题：" class="headerlink" title="2．内存操作顺序改变所带来的问题："></a>2．内存操作顺序改变所带来的问题：</h2><p>在O2优化后，编译器会对影响内存操作的执行顺序。例如：-fschedule-insns允许数据处理时先完成其他的指令；-fforce-mem有可能导致内存与寄存器之间的数据产生类似脏数据的不一致等。对于某些依赖内存操作顺序而进行的逻辑，需要做严格的处理后才能进行优化。例如，采用volatile关键字限制变量的操作方式，或者利用barrier迫使cpu严格按照指令序执行的。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">echo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/02/03/Gcc%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/">http://example.com/2021/02/03/Gcc%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">echo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="http://p9.qhimg.com/bdr/__85/t01269a467cd28225d2.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/05/UniformInitialization/"><img class="prev-cover" src="http://p5.qhimg.com/bdm/0_0_100/t01dfe78c9e02a650c3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UniformInitialization</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/04/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8B/"><img class="next-cover" src="http://p3.qhimg.com/bdr/__85/t017191849405214f61.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程基础下</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/05/3B-server开发文档/" title="3B+server开发文档"><img class="cover" src="http://p3.qhimg.com/bdr/__85/t017191849405214f61.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-05</div><div class="title">3B+server开发文档</div></div></a></div><div><a href="/2021/01/02/linux常用小技巧/" title="linux常用小技巧"><img class="cover" src="http://p8.qhimg.com/bdm/0_0_100/t01659e0702e7e8b2f9.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-02</div><div class="title">linux常用小技巧</div></div></a></div><div><a href="/2021/01/02/linux进程基础/" title="linux进程基础"><img class="cover" src="http://p7.qhimg.com/bdm/0_0_100/t01c329322d50c5536d.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-02</div><div class="title">linux进程基础</div></div></a></div><div><a href="/2020/10/11/makefile的编写/" title="makefile的编写"><img class="cover" src="http://p2.qhimg.com/bdm/0_0_100/t01b079bc5131c99a6b.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-11</div><div class="title">makefile的编写</div></div></a></div><div><a href="/2021/01/02/课程设计开发笔记/" title="课程设计开发笔记"><img class="cover" src="http://p4.qhimg.com/bdm/0_0_100/t019def674785e03ef1.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-02</div><div class="title">课程设计开发笔记</div></div></a></div><div><a href="/2021/01/02/linux多线程/" title="linux多线程"><img class="cover" src="http://p0.qhimg.com/bdm/0_0_100/t01523e547b0c6f586f.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-02</div><div class="title">linux多线程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">D</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment">i</span></div></div><div class="comment-wrap"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></article></main><footer id="footer" style="background-image: url(http://p9.qhimg.com/bdr/__85/t01269a467cd28225d2.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By echo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350},"mobile":{"show":true},"log":false});</script></body></html>